blueprint:
  name: "Boiler Weather Compensation with Solar Gain"
  description: >-
    Adjusts boiler flow temperature based on outdoor temperature and sun
    illuminance (lux). Uses the radiator nonlinearity exponent (0.78) from the
    Vaillant/Kühne heat curves, but without coupling to any single room
    temperature — ideal for multi-zone houses where each zone has its own
    thermostat

    On sunny days, the flow temperature is reduced to prevent overheating from
    solar gain through windows.

    Reference:
    https://protonsforbreakfast.wordpress.com/2024/10/16/vaillant-heat-pump-controls-part-1-the-heat-curves/
  domain: automation
  source_url: https://github.com/dlbogdan/boiler-outdoor-dep/blob/main/boiler_weather_compensation.yaml

  input:
    # ── Entity selection (proper UI pickers) ──────────────────────────────
    outdoor_temp_sensor:
      name: "Outdoor Temperature Sensor"
      description: "Sensor that reports outdoor temperature in °C"
      selector:
        entity:
          domain: sensor
          device_class: temperature

    outdoor_lux_sensor:
      name: "Outdoor Illuminance Sensor"
      description: "Sensor that reports outdoor light level in lux"
      selector:
        entity:
          domain: sensor
          device_class: illuminance

    boiler_climate:
      name: "Boiler / Heating Climate Entity"
      description: "Climate entity for the boiler. Always required — used for HVAC mode (on/off). Temperature is also set here unless the number entity override below is configured."
      selector:
        entity:
          domain: climate

    boiler_number_entity:
      name: "Boiler Flow Temp Number Entity (optional override)"
      description: "When set, flow temperature is written to this number entity instead of the climate entity (bypasses any temperature cap in the climate integration). HVAC on/off still goes through the climate entity above. E.g. number.e3_vitodens_100_hc_0122_normal_temperature"
      default: ""
      selector:
        entity:
          domain: number

    # ── Heat curve anchor points ──────────────────────────────────────────
    design_outdoor_temp:
      name: "Design Outdoor Temperature"
      description: "Coldest outdoor temperature you expect (°C)"
      default: -20
      selector:
        number:
          min: -30
          max: 5
          step: 1
          unit_of_measurement: "°C"
          mode: slider

    design_flow_temp:
      name: "Design Flow Temperature"
      description: "Flow temperature needed on the coldest day (°C). Calibrated: 77 °C at -20 °C gives ~54 °C at 0 °C (with curve base 25 °C)."
      default: 77
      selector:
        number:
          min: 30
          max: 80
          step: 1
          unit_of_measurement: "°C"
          mode: slider

    curve_base_temp:
      name: "Curve Base Temperature"
      description: "Flow temperature at the heating-off threshold — the bottom anchor of the heat curve. This shapes the curve; use 'Minimum Flow Temperature' for a safety floor."
      default: 25
      selector:
        number:
          min: 15
          max: 40
          step: 1
          unit_of_measurement: "°C"
          mode: slider

    min_flow_temp:
      name: "Minimum Flow Temperature"
      description: "Hard lower limit (safety floor) for the output flow temperature (°C). Does not affect the shape of the heat curve."
      default: 25
      selector:
        number:
          min: 15
          max: 40
          step: 1
          unit_of_measurement: "°C"
          mode: slider

    heating_off_outdoor_temp:
      name: "Outdoor Temp - Heating Off"
      description: "Above this outdoor temperature, heating turns off (°C). Must be higher than 'Heating On' to create a hysteresis dead zone."
      default: 18
      selector:
        number:
          min: 10
          max: 25
          step: 0.5
          unit_of_measurement: "°C"
          mode: slider

    heating_on_outdoor_temp:
      name: "Outdoor Temp - Heating On"
      description: "Below this outdoor temperature, heating turns back on (°C). Must be lower than 'Heating Off' to prevent rapid toggling."
      default: 13
      selector:
        number:
          min: 5
          max: 20
          step: 0.5
          unit_of_measurement: "°C"
          mode: slider

    # ── Solar gain correction ─────────────────────────────────────────────
    lux_threshold_low:
      name: "Lux Threshold - Start Reduction"
      description: "Illuminance (lux) at which solar offset begins"
      default: 10000
      selector:
        number:
          min: 0
          max: 50000
          step: 1000
          unit_of_measurement: "lx"
          mode: slider

    lux_threshold_high:
      name: "Lux Threshold - Max Reduction"
      description: "Illuminance (lux) at which solar offset reaches maximum"
      default: 40000
      selector:
        number:
          min: 0
          max: 100000
          step: 1000
          unit_of_measurement: "lx"
          mode: slider

    lux_max_offset:
      name: "Max Solar Offset"
      description: "Maximum flow temperature reduction due to sun (°C). This is the full capacity of the solar heat accumulator."
      default: 5
      selector:
        number:
          min: 0
          max: 15
          step: 0.5
          unit_of_measurement: "°C"
          mode: slider

    solar_accumulator_helper:
      name: "Solar Heat Accumulator (input_number)"
      description: "An input_number helper that stores the solar heat soak level (0 to max offset). Create one with min=0, max=15, step=0.1. Displays on your dashboard as a gauge of how 'charged' the house is with solar heat."
      selector:
        entity:
          domain: input_number

    solar_charge_rate:
      name: "Solar Charge Rate"
      description: "How fast the solar accumulator charges at full sun intensity (°C per minute). At 0.2°C/min, full sun reaches 5°C cap in ~33 min (accounting for simultaneous decay)."
      default: 0.2
      selector:
        number:
          min: 0.01
          max: 2.0
          step: 0.01
          unit_of_measurement: "°C/min"
          mode: slider

    solar_decay_rate:
      name: "Solar Decay Rate"
      description: "How fast the solar accumulator decays when there is no sun (°C per minute). At 0.1°C/min, a fully charged 5°C accumulator takes ~50 min to discharge completely."
      default: 0.1
      selector:
        number:
          min: 0.01
          max: 1.0
          step: 0.01
          unit_of_measurement: "°C/min"
          mode: slider

    lux_multiplier:
      name: "Lux Sensor Multiplier"
      description: "Scale factor for the lux reading. Use >1 if the sensor is partially shaded (e.g. 2.0 = sensor reads half of real sun). Use <1 if sensor is over-exposed."
      default: 1.0
      selector:
        number:
          min: 0.1
          max: 5.0
          step: 0.1
          unit_of_measurement: "×"
          mode: slider

    # ── Heating demand — PI controller ─────────────────────────────────────
    heating_demand_sensor:
      name: "Total Heating Demand Sensor (optional)"
      description: "Sensor reporting total heating demand (0-100). Drives the PI controller that adjusts flow temperature. Leave empty to disable demand-based adjustment."
      default: ""
      selector:
        entity:
          domain: sensor

    heating_demand_neutral:
      name: "PI Neutral Point"
      description: "Demand value that produces zero P/I adjustment. Below this, the P-term reduces flow temp and the I-term decays; above it, P-term increases flow temp and I-term charges."
      default: 3
      selector:
        number:
          min: 0
          max: 100
          step: 0.5
          mode: slider

    heating_demand_rate:
      name: "P-Gain (°C per demand unit)"
      description: "Proportional gain: immediate °C of flow temperature offset per unit of demand deviation from neutral. E.g. 0.1 means demand 10 above neutral → +1°C instant offset."
      default: 0.1
      selector:
        number:
          min: 0.05
          max: 1.0
          step: 0.05
          unit_of_measurement: "°C/unit"
          mode: slider

    max_demand_offset:
      name: "Max P-Offset"
      description: "Maximum °C the proportional (P) term can add or subtract from the base flow temperature, regardless of P-gain."
      default: 10
      selector:
        number:
          min: 1
          max: 30
          step: 1
          unit_of_measurement: "°C"
          mode: slider

    demand_integral_helper:
      name: "Demand I-Term Accumulator (input_number)"
      description: "An input_number helper that stores the integral (I) demand offset (-max to +max). Create one with min=-15, max=15, step=0.1. Leave empty to disable the I-term (P-only mode). Positive = sustained over-demand boosting flow; negative = sustained under-demand reducing flow."
      default: ""
      selector:
        entity:
          domain: input_number

    demand_integral_charge_rate:
      name: "I-Term Rate"
      description: "How fast the I-term moves per unit of demand deviation from neutral, per minute (°C/unit/min). Scales with error magnitude: larger deviations charge faster. At 0.05 with deviation=5, the rate is 0.25°C/min → reaches 5°C cap in ~20 min. Now updates only on the periodic timer so the rate is predictable."
      default: 0.05
      selector:
        number:
          min: 0.01
          max: 1.0
          step: 0.01
          unit_of_measurement: "°C/(unit·min)"
          mode: slider

    demand_integral_decay_rate:
      name: "I-Term Decay Rate (at neutral)"
      description: "How fast the I-term decays toward zero when demand equals neutral (°C per minute). Provides a slow return to baseline even when demand sits right at neutral. At 0.1, a 2°C accumulator takes ~20 min to reach zero."
      default: 0.1
      selector:
        number:
          min: 0.01
          max: 1.0
          step: 0.01
          unit_of_measurement: "°C/min"
          mode: slider

    demand_integral_max:
      name: "Max I-Offset (absolute)"
      description: "Hard cap on the integral (I) accumulator in both directions. The I-term is clamped to [-max, +max]. Limits how much the I-term can boost or reduce flow temperature."
      default: 5
      selector:
        number:
          min: 1
          max: 15
          step: 0.5
          unit_of_measurement: "°C"
          mode: slider

    # ── Output clamp ─────────────────────────────────────────────────────
    max_flow_temp:
      name: "Maximum Flow Temperature"
      description: "Hard upper limit for the calculated flow temperature (°C)"
      default: 67
      selector:
        number:
          min: 45
          max: 75
          step: 1
          unit_of_measurement: "°C"
          mode: slider

    # ── API rate limiting ────────────────────────────────────────────────
    min_change_threshold:
      name: "Minimum Change Threshold"
      description: "Only send a new temperature to the boiler if the target differs from the current setpoint by at least this many degrees. Reduces unnecessary API calls."
      default: 2
      selector:
        number:
          min: 1
          max: 10
          step: 1
          unit_of_measurement: "°C"
          mode: slider

# ═══════════════════════════════════════════════════════════════════════════
# Automation definition
# ═══════════════════════════════════════════════════════════════════════════
mode: restart

trigger:
  # Periodic re-evaluation
  - platform: time_pattern
    minutes: "/5"
    id: periodic

  # React to outdoor temperature changes (debounced — wait 5 min of stable value)
  - platform: state
    entity_id: !input outdoor_temp_sensor
    id: outdoor_temp_change
    for:
      minutes: 5

  # React to illuminance swings (debounced — wait 5 min of stable value)
  - platform: state
    entity_id: !input outdoor_lux_sensor
    id: lux_change
    for:
      minutes: 5

  # React to heating demand changes (debounced — wait 10 min of stable value)
  # Demand is still read every run; this just prevents the demand sensor
  # from triggering excessively frequent re-evaluations.
  - platform: state
    entity_id: !input heating_demand_sensor
    id: demand_change
    for:
      minutes: 5

condition: []

action:
  # ── Resolve entity IDs from blueprint inputs ───────────────────────────
  - variables:
      outdoor_temp_entity: !input outdoor_temp_sensor
      outdoor_lux_entity: !input outdoor_lux_sensor
      heating_demand_entity: !input heating_demand_sensor
      solar_accum_entity: !input solar_accumulator_helper
      demand_integral_entity: !input demand_integral_helper
      boiler_climate_entity: !input boiler_climate
      boiler_number: !input boiler_number_entity
      use_number_mode: "{{ boiler_number | default('', true) | length > 0 }}"

  # ── Check sensor availability before proceeding ────────────────────────
  - condition: template
    value_template: >-
      {{ states(outdoor_temp_entity) not in ['unavailable', 'unknown']
         and states(outdoor_lux_entity) not in ['unavailable', 'unknown'] }}

  # ── Gather all inputs into variables ────────────────────────────────────
  - variables:
      # Sensor readings
      t_out: "{{ states(outdoor_temp_entity) | float(10) }}"
      lux_raw: "{{ states(outdoor_lux_entity) | float(0) }}"
      lux_mult: !input lux_multiplier
      lux: "{{ (lux_raw | float * lux_mult | float) | round(0) }}"

      # Heat curve parameters
      t_design: !input design_outdoor_temp
      flow_design: !input design_flow_temp
      curve_base: !input curve_base_temp
      flow_min: !input min_flow_temp
      t_off: !input heating_off_outdoor_temp
      t_on: !input heating_on_outdoor_temp

      # Solar parameters
      lux_low: !input lux_threshold_low
      lux_high: !input lux_threshold_high
      max_solar_offset: !input lux_max_offset
      solar_charge: !input solar_charge_rate
      solar_decay: !input solar_decay_rate
      solar_accum_prev: "{{ states(solar_accum_entity) | float(0) }}"
      solar_dt_min: >-
        {% set last = state_attr(solar_accum_entity, 'last_updated') or state_attr(solar_accum_entity, 'last_changed') %}
        {% if last %}
          {{ ((now() - last).total_seconds() / 60) | round(2) }}
        {% else %}
          1
        {% endif %}

      # Heating demand — PI controller parameters
      demand_neutral: !input heating_demand_neutral
      demand_rate: !input heating_demand_rate
      demand_max_p_offset: !input max_demand_offset

      # Heating demand — P-term (proportional offset from neutral)
      demand_raw: >-
        {% if heating_demand_entity | default('', true) | length > 0
           and states(heating_demand_entity) not in ['unavailable', 'unknown', ''] %}
          {{ states(heating_demand_entity) | float(0) }}
        {% else %}
          {{ demand_neutral }}
        {% endif %}
      demand_p_offset: "{{ [[-1 * demand_max_p_offset | float, ((demand_raw | float - demand_neutral | float) * demand_rate | float)] | max, demand_max_p_offset | float] | min | round(1) }}"

      # Heating demand — I-term parameters
      demand_i_charge_rate: !input demand_integral_charge_rate
      demand_i_decay_rate: !input demand_integral_decay_rate
      demand_i_max: !input demand_integral_max
      demand_i_prev: >-
        {% if demand_integral_entity | default('', true) | length > 0
           and states(demand_integral_entity) not in ['unavailable', 'unknown', ''] %}
          {{ states(demand_integral_entity) | float(0) }}
        {% else %}
          0
        {% endif %}
      demand_i_dt: >-
        {% if demand_integral_entity | default('', true) | length > 0 %}
          {% set last = state_attr(demand_integral_entity, 'last_updated') or state_attr(demand_integral_entity, 'last_changed') %}
          {% if last %}
            {{ ((now() - last).total_seconds() / 60) | round(2) }}
          {% else %}
            1
          {% endif %}
        {% else %}
          0
        {% endif %}

      # Output clamp
      flow_max: !input max_flow_temp

      # Radiator nonlinearity exponent (convection ΔT^1.3 → inverse ≈ 0.78)
      b: 0.78

  # ── Compute flow temperature ────────────────────────────────────────────
  - variables:
      # Base flow temp from heat curve
      base_flow: >-
        {% if t_out | float >= t_off | float %}
          {{ curve_base }}
        {% elif t_out | float <= t_design | float %}
          {{ flow_design }}
        {% else %}
          {% set demand = (t_off | float - t_out | float) / (t_off | float - t_design | float) %}
          {{ (curve_base | float + (flow_design | float - curve_base | float) * (demand ** b)) | round(1) }}
        {% endif %}

      # Solar heat accumulator: charge with sun, decay without
      lux_fraction: >-
        {% if lux | float <= lux_low | float %}
          0
        {% elif lux | float >= lux_high | float %}
          1
        {% else %}
          {{ ((lux | float - lux_low | float) / (lux_high | float - lux_low | float)) | round(3) }}
        {% endif %}
      solar_offset: >-
        {% set dt = [solar_dt_min | float, 30] | min %}
        {% set charge = lux_fraction | float * solar_charge | float * dt %}
        {% set decay = solar_decay | float * dt if lux_fraction | float == 0 else 0 %}
        {% set new_val = solar_accum_prev | float + charge - decay %}
        {{ [0, [new_val, max_solar_offset | float] | min] | max | round(1) }}

      # Demand I-term accumulator: deviation-scaled bidirectional — charges proportional to (demand - neutral)
      demand_i_offset: >-
        {% if demand_integral_entity | default('', true) | length == 0 %}
          0
        {% else %}
          {% set dt = [demand_i_dt | float, 30] | min %}
          {% set deviation = demand_raw | float - demand_neutral | float %}
          {% set decay_toward_zero = demand_i_decay_rate | float * dt %}
          {% set prev = demand_i_prev | float %}
          {% if deviation | float != 0 %}
            {% set charge = deviation * demand_i_charge_rate | float * dt %}
            {% set new_val = prev + charge %}
          {% else %}
            {% if prev > 0 %}
              {% set new_val = [prev - decay_toward_zero, 0] | max %}
            {% elif prev < 0 %}
              {% set new_val = [prev + decay_toward_zero, 0] | min %}
            {% else %}
              {% set new_val = 0 %}
            {% endif %}
          {% endif %}
          {{ [(-1 * demand_i_max | float), [new_val, demand_i_max | float] | min] | max | round(1) }}
        {% endif %}

  # ── Write solar accumulator back to helper (only on periodic trigger) ───
  - if:
      - condition: trigger
        id: periodic
    then:
      - service: input_number.set_value
        target:
          entity_id: !input solar_accumulator_helper
        data:
          value: "{{ solar_offset }}"

  # ── Write demand I-term accumulator back to helper (only on periodic trigger) ─
  - if:
      - condition: and
        conditions:
          - condition: trigger
            id: periodic
          - condition: template
            value_template: "{{ demand_integral_entity | default('', true) | length > 0 }}"
    then:
      - service: input_number.set_value
        target:
          entity_id: !input demand_integral_helper
        data:
          value: "{{ demand_i_offset }}"

  - variables:
      # PI demand offset applied to base flow
      demand_adjusted_flow: >-
        {{ (base_flow | float + demand_p_offset | float + demand_i_offset | float) | round(1) }}
      # Raw target before clamping (used to detect "no real demand")
      target_flow_raw: >-
        {{ (demand_adjusted_flow | float - solar_offset | float) | round(1) }}
      # Final clamped target (integer for boiler)
      target_flow: >-
        {{ [flow_min | float, [target_flow_raw | float, flow_max | float] | min] | max | round(0) | int }}

  # ── Rate limiting: read current boiler setpoint ─────────────────────
  - variables:
      min_change: !input min_change_threshold
      current_setpoint: >-
        {% if use_number_mode %}
          {{ states(boiler_number) | float(0) }}
        {% else %}
          {{ state_attr(boiler_climate_entity, 'temperature') | float(0) }}
        {% endif %}
      current_mode: "{{ states(boiler_climate_entity) }}"
      change_big_enough: "{{ (target_flow | int - current_setpoint | int) | abs >= min_change | int }}"
      # Should we turn off? (outdoor warm enough OR calculated flow ≤ minimum)
      should_heat_off: "{{ t_out | float >= t_off | float or target_flow_raw | float <= flow_min | float }}"
      # Should we turn on? (outdoor cold enough AND calculated flow is above minimum —
      # prevents toggle when it's cold but solar gain makes heating pointless)
      should_heat_on: "{{ t_out | float < t_on | float and target_flow_raw | float > flow_min | float }}"
      # Dead zone: between t_on and t_off → maintain current state
      in_dead_zone: "{{ not should_heat_off and not should_heat_on }}"
      # Calculated flow too low → treat like outdoor-warm-enough
      flow_below_min: "{{ target_flow_raw | float <= flow_min | float }}"
      # Mode change (off → heat or heat → off) always goes through
      mode_change: >-
        {% if should_heat_off and current_mode != 'off' %}true
        {% elif should_heat_on and current_mode == 'off' %}true
        {% else %}false{% endif %}
      # In dead zone while off → suppress updates entirely (stay off)
      dead_zone_hold: "{{ in_dead_zone and current_mode == 'off' }}"
      should_update: "{{ not dead_zone_hold and (mode_change == 'true' or change_big_enough) }}"

  # ── Skip if no meaningful change ─────────────────────────────────────
  - condition: template
    value_template: "{{ should_update }}"

  # ── Apply to boiler ────────────────────────────────────────────────────
  - choose:
      # Outdoor temp warm enough → turn heating off
      - conditions:
          - condition: template
            value_template: "{{ t_out | float >= t_off | float }}"
        sequence:
          - service: climate.set_hvac_mode
            target:
              entity_id: "{{ boiler_climate_entity }}"
            data:
              hvac_mode: "off"
          - service: system_log.write
            data:
              message: >-
                Weather Comp: Outdoor {{ t_out }}°C ≥ off-threshold {{ t_off }}°C → heating OFF (on-threshold {{ t_on }}°C)
              level: info

      # Calculated flow temp at or below minimum → no real demand, turn off
      - conditions:
          - condition: template
            value_template: "{{ flow_below_min }}"
        sequence:
          - service: climate.set_hvac_mode
            target:
              entity_id: "{{ boiler_climate_entity }}"
            data:
              hvac_mode: "off"
          - service: system_log.write
            data:
              message: >-
                Weather Comp: Calculated flow {{ target_flow_raw }}°C ≤ min {{ flow_min }}°C → no demand, heating OFF
              level: info

      # Dead zone: between t_on and t_off while currently off → stay off
      - conditions:
          - condition: template
            value_template: "{{ in_dead_zone and current_mode == 'off' }}"
        sequence:
          - service: system_log.write
            data:
              message: >-
                Weather Comp: Outdoor {{ t_out }}°C in dead zone ({{ t_on }}–{{ t_off }}°C), currently off → staying OFF
              level: info

    # Otherwise → set calculated flow temperature
    default:
      - if:
          - condition: template
            value_template: "{{ use_number_mode }}"
        then:
          - service: number.set_value
            target:
              entity_id: "{{ boiler_number }}"
            data:
              value: "{{ target_flow }}"
          - service: climate.set_hvac_mode
            target:
              entity_id: "{{ boiler_climate_entity }}"
            data:
              hvac_mode: auto
        else:
          - service: climate.set_temperature
            target:
              entity_id: "{{ boiler_climate_entity }}"
            data:
              temperature: "{{ target_flow }}"
              hvac_mode: auto
      - service: system_log.write
        data:
          message: >-
            Weather Comp: Outdoor={{ t_out }}°C (on<{{ t_on }}°C, off≥{{ t_off }}°C),
            Lux={{ lux }}(raw={{ lux_raw }},x={{ lux_mult }}),
            SolarAccum={{ solar_offset }}°C(prev={{ solar_accum_prev }},dt={{ solar_dt_min }}min,lux_frac={{ lux_fraction }},+{{ (lux_fraction | float * solar_charge | float * [solar_dt_min | float, 30] | min) | round(2) }},-{{ (solar_decay | float * [solar_dt_min | float, 30] | min) if lux_fraction | float == 0 else 0 }}),
            Base={{ base_flow }}°C, DemandAdj={{ demand_adjusted_flow }}°C(P={{ demand_p_offset }}°C,I={{ demand_i_offset }}°C,demand={{ demand_raw }},neutral={{ demand_neutral }},rate={{ demand_rate }}),
            MaxClamp={{ flow_max }}°C, Prev={{ current_setpoint }}°C, Δ={{ (target_flow | int - current_setpoint | int) | abs }}°C
            → Flow target={{ target_flow }}°C
          level: info
